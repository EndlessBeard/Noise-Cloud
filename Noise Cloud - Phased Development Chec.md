## Noise Cloud - Phased Development Checklist

**Project Goal:** Create an interactive webpage using PixiJS to display a visualization generated by a custom GLSL shader utilizing a 3D Perlin noise function, controllable via a collapsible side panel with well-organized UI elements for fine-grained parameter adjustments, incorporating post-processing to generate normals and simulate lighting effects.

**Phase 1: Core Setup & Basic Rendering**

*   [ ] **Environment Setup:**
    *   [ ] Install Node.js and NPM
    *   [ ] Initialize Project: `npm create vite noise-cloud --template vanilla`
    *   [ ] Install Dependencies: `npm install pixi.js lil-gui tinygradient`
*   [ ] **Vite Configuration:**
    *   [ ] Configure `vite.config.js` to handle GLSL files as raw text (`assetsInclude`).
*   [ ] **Basic PixiJS Setup:**
    *   [ ] Initialize a PixiJS application (stage, renderer, ticker) in `src/main.js`.
    *   [ ] Handle window resize for responsive rendering.
*   [ ] **Shader Loading:**
    *   [ ] Create `src/utils/ShaderLoader.js` to asynchronously load GLSL shaders from files.
*   [ ] **Initial Shader & Sprite:**
    *   [ ] Create a simple GLSL fragment shader (`src/shaders/my_shader.frag`) for basic output (solid color/gradient).
    *   [ ] Create a PixiJS Sprite (or Graphics) and apply the initial shader.
    *   [ ] Pass resolution as a uniform.
*   [ ] **Basic Animation:**
    *   [ ] Pass `u_time` uniform for animation.
*   [ ] **Version Control:**
    *   [ ] Initialize Git repository.
    *   [ ] Make initial commit.

**Phase 2: Custom Perlin Noise Implementation & Integration**

*   [ ] **Perlin Analysis & Conversion:**
    *   [ ] Analyze existing custom Perlin implementation (identify core logic, data structures).
    *   [ ] Convert the Perlin implementation to GLSL (optimize for shader performance).
    *   [ ] Verify the GLSL implementation produces the same (or similar) output as the original.
*   [ ] **3D Perlin Integration:**
    *   [ ] Replace the basic shader with the 3D Perlin noise shader in `src/shaders/my_shader.frag`.
    *   [ ] Verify the Perlin noise is rendering correctly (basic visual check).
*   [ ] **Speed Control Uniforms:**
    *   [ ] Pass speed control uniforms (X, Y, Z, Freq Scaling X, Y, Z) to the shader.
*   [ ] **Commit Changes:**
    *   [ ] Commit the working Perlin noise implementation.

**Phase 3: UI Structure & Overall Noise Controls**

*   [ ] **Collapsible Panel:**
    *   [ ] Create `src/ui/Panel.js` for the collapsible side panel.
    *   [ ] Integrate the panel into `index.html`.
    *   [ ] Initialize the panel in `src/main.js`.
*   [ ] **Overall Noise Controls UI:**
    *   [ ] Create `src/ui/NoiseControls.js`.
    *   [ ] Implement UI for:
        *   Seed
        *   Global Frequency
        *   Global Amplitude
        *   X Speed
        *   Y Speed
        *   Z Speed
        *   Frequency Scaling X
        *   Frequency Scaling Y
        *   Frequency Scaling Z
    *   [ ] Connect UI elements to shader uniforms.
*   [ ] **Seed Uniform:**
    *   [ ] Add seed functionality to the shader.
*   [ ] **Parameter Uniforms:**
    *   [ ] Add Global Parameter functionality to the shader.
*   [ ] **Commit Changes:**
    *   [ ] Commit the UI framework and seed control.

**Phase 4: NOISE_MASK Implementation & UI**

*   [ ] **NOISE_MASK Implementation:**
    *   [ ] Implement Domain Warping in the shader.
    *   [ ] Implement NOISE_MASK (Domain Warped Perlin, layer splitting).
    *   [ ] Pass NOISE_MASK parameters as uniforms.
*   [ ] **NOISE_MASK UI:**
    *   [ ] Add a subpanel for NOISE_MASK in `src/ui/NoiseControls.js`.
    *   [ ] Implement UI for:
        *   Frequency
        *   Amplitude
        *   Octaves
        *   Gain
        *   Domain Warping Intensity
        *   Domain Warping Scale
        *   Cutoff 1
        *   Cutoff 2
        *   Softness
    *   [ ] Connect UI elements to shader uniforms.
*   [ ] **Commit Changes:**
    *   [ ] Commit the NOISE_MASK implementation and UI.

**Phase 5: BASE_NOISE Implementation & UI**

*   [ ] **BASE_NOISE Implementation:**
    *   [ ] Implement BASE_NOISE (Domain Warped Perlin within each layer).
    *   [ ] Implement relative parameter offsets.
*   [ ] **Color Gradient Implementation:**
    *   [ ] Implement the `ColorGradient.js` utility.
    *   [ ] Integrate `tinygradient` for color stop selection in the UI.
    *   [ ] Pass color gradient data to the shader as a uniform.
*   [ ] **BASE_NOISE UI:**
    *   [ ] Add a subpanel for BASE_NOISE with sub-subpanels for each layer (BASE1, BASE2, BASE3).
    *   [ ] Implement UI for:
        *   Relative Position/Frequency/Amplitude Offsets
        *   Perlin Noise controls for each layer
        *   Domain Warping controls for each layer
        *   Warp Type (dropdown)
        *   Base Noise features for Warp
        *   Color gradient controls
    *   [ ] Connect UI elements to shader uniforms.
*   [ ] **Commit Changes:**
    *   [ ] Commit the BASE_NOISE implementation and UI.

**Phase 6: Post-Processing & Lighting**

*   [ ] **Normal Calculation Shader:**
    *   [ ] Create `src/shaders/normal_shader.frag` to calculate normals.
*   [ ] **Lighting Implementation:**
    *   [ ] Implement diffuse lighting in `normal_shader.frag`.
*   [ ] **PixiJS Integration:**
    *   [ ] Render noise output to `PIXI.RenderTexture`.
    *   [ ] Apply `normal_shader.frag` to a second sprite sampling the `RenderTexture`.
    *   [ ] Compose the sprites on the stage.
*   [ ] **Lighting Controls UI:**
    *   [ ] Add lighting controls to the "Overall Noise Controls" in `src/ui/NoiseControls.js`:
        *   Light Direction X, Y, Z
        *   Light Color
    *   [ ] Connect UI elements to shader uniforms.
*   [ ] **Lighting Uniforms:**
    *   [ ] Pass Lighting parameters as uniforms to `normal_shader.frag`.
*   [ ] **Commit Changes:**
    *   [ ] Commit the post-processing and lighting implementation.

**Phase 7: Optimization, Refinement, & Polish**

*   [ ] **Performance Profiling:**
    *   [ ] Profile performance using browser developer tools.
*   [ ] **GLSL Optimization:**
    *   [ ] Optimize GLSL code for performance (reduce computations, use efficient data types).
*   [ ] **UI/UX Refinement:**
    *   [ ] Refine the UI/UX based on user feedback and best practices.
*   [ ] **Code Cleanup & Refactoring:**
    *   [ ] Lint code, add comments, and refactor as needed.
*   [ ] **Testing:**
    *   [ ] Test on different devices and browsers.
*   [ ] **Final Commit:**
    *   [ ] Commit the final optimized and polished version.

**Phase 8: (Optional) Deployment**

*   [ ] **Build:**
    *   [ ] Run `npm run build`.
*   [ ] **Deployment:**
    *   [ ] Deploy the contents of the `dist` directory to a hosting service.

This checklist provides a structured approach to the development process. Remember to commit your changes frequently and test each phase thoroughly. Good luck! Let me know when you want to start!
