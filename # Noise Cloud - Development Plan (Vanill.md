# Noise Cloud - Development Plan (Vanilla JS)

**Goal:** Create an interactive webpage using PixiJS to display a visualization generated by a custom GLSL shader utilizing a 3D Perlin noise function, controllable via a collapsible side panel with well-organized UI elements for fine-grained parameter adjustments, and incorporating post-processing to generate normals and simulate lighting effects.

**I. Project Setup & Core Structure**

1.  **Environment Setup**
    *   Install Node.js and NPM
    *   Initialize Project: `npm create vite glsl-playground --template vanilla`
    *   Install Dependencies: `npm install pixi.js lil-gui tinygradient`
    *   Directory Structure:
        ```
        glsl-playground/
        ├── index.html
        ├── src/
        │   ├── main.js        // Entry point
        │   ├── shaders/
        │   │   ├── my_shader.frag  // Main noise shader
        │   │   └── normal_shader.frag // Post-processing normal calculation
        │   ├── ui/
        │   │   ├── Panel.js   // Collapsible Panel
        │   │   └── NoiseControls.js // Noise parameter controls
        │   └── utils/
        │       ├── ShaderLoader.js // Shader loading utility
        │       └── ColorGradient.js // Color Gradient Utility
        ├── public/            // Assets (optional)
        ├── vite.config.js
        ├── package.json
        └── ...
        ```

2.  **Vite Configuration**
    *   Configure `vite.config.js` to handle GLSL files as raw text (essential for shader loading). Add `assetsInclude` config.

3.  **Basic PixiJS Setup**
    *   Initialize a PixiJS application (stage, renderer, ticker) in `src/main.js`.
    *   Handle window resize for responsive rendering.

4.  **Shader Loading**
    *   Create `src/utils/ShaderLoader.js` with a function to asynchronously load GLSL shaders from files using `fetch`. Implement error handling for loading failures.

5.  **Initial Shader & Sprite**
    *   Create a simple GLSL fragment shader (`src/shaders/my_shader.frag`) that outputs a basic visual (e.g., solid color or gradient).
    *   In `src/main.js`, create a PixiJS Sprite (or Graphics) and apply the shader to it using `PIXI.Filter`.
    *   Pass the resolution as a uniform to the shader.

6.  **Basic Animation**
    *   Pass the current time as a uniform (`u_time`) from JavaScript to the shader.
    *   Modify the shader to use `u_time` for animation.

**II. UI Development: Collapsible Panel & Noise Controls**

1.  **Collapsible Panel**
    *   Create `src/ui/Panel.js` to handle the collapsible side panel UI.
        *   Create the panel element with HTML and Javascript.
        *   Add a toggle button (☰) to collapse/expand the panel.
        *   Use CSS for appearance, positioning, and animation (transition).
        *   Implement a method to add content elements to the panel.
    *   Integrate the panel into `index.html`.
    *   In `src/main.js`, import and initialize the panel, and call method to add content.

2.  **Noise Controls**
    *   Create `src/ui/NoiseControls.js` to manage UI elements for controlling noise parameters using `lil-gui`, organized into subpanels reflecting the shader flow:
        *   **Overall Noise Controls:** A set of global controls that affect all noise functions. These will be a base that layer-specific controls offset from.
            *   Seed (for all Perlin functions)
            *   Global Frequency
            *   Global Amplitude
            *   **Speed Controls:**
                *   X Speed
                *   Y Speed
                *   Z Speed
                *   Frequency Scaling X
                *   Frequency Scaling Y
                *   Frequency Scaling Z
        *   **NOISE_MASK Subpanel:**
            *   Perlin Noise controls:
                *   Frequency
                *   Amplitude
                *   Octaves
                *   Gain
            *   Domain Warping controls:
                *   Intensity
                *   Scale
            *   Mask Layer Controls:
                *   Cutoff 1
                *   Cutoff 2
                *   Softness (controls transition sharpness between layers)
        *   **BASE_NOISE Subpanel:**
            *   Controls for each layer (BASE1, BASE2, BASE3), presented as sub-subpanels within BASE_NOISE.
                *   **BASE Layer Controls:**
                    *   **Relative Offset:**
                        *   Position Offset X
                        *   Position Offset Y
                        *   Position Offset Z
                        *   Frequency Offset
                        *   Amplitude Offset
                    *   Perlin Noise controls:
                        *   Frequency
                        *   Amplitude
                        *   Octaves
                        *   Gain
                    *   **Color Gradient:** (Using `tinygradient`)
                        *   UI to select color stops for the gradient. Store this as a data structure to be passed to the shader.
                *   **WARP Layer Controls:**
                    *   **Relative Offset:**
                        *   Position Offset X
                        *   Position Offset Y
                        *   Position Offset Z
                        *   Frequency Offset
                        *   Amplitude Offset
                    *   Domain Warping controls:
                        *   Intensity
                        *   Scale
                        *   Warp Type (Dropdown): Add, Multiply, Exponential, Logarithmic
                        *   Base Noise Features for Warp
                            *   Frequency
                            *   Amplitude
                            *   Octaves
                            *   Gain

    *   Implement slim, sleek, and intuitive UI/UX principles using `lil-gui` (consider its styling options and nesting capabilities). Prioritize clear labeling and logical grouping of controls.
    *   **Lighting Controls:** Add controls for light direction and color. These will be added to the "Overall Noise Controls" section.
        *   Light Direction X
        *   Light Direction Y
        *   Light Direction Z
        *   Light Color

**III. Shader Development & Refinement**

1.  **Implement Noise Functions in GLSL**
    *   Implement 3D Perlin noise function in `my_shader.frag`.
    *   Implement Domain Warping with different warp types (Add, Multiply, Exponential, Logarithmic).
    *   Implement NOISE_MASK:
        *   Domain Warped Perlin noise.
        *   Split output into MASK1, MASK2, and MASK3 using two cutoff values and the SOFTNESS control.
    *   Implement BASE_NOISE:
        *   Domain Warped Perlin noise.
        *   Fill each layer defined by NOISE_MASK with BASE_NOISE, using layer-specific parameter offsets.
    *   Implement color gradient functionality, receiving color stop data from JavaScript.
    *   Pass all relevant parameters as uniforms from JavaScript to the shader, including speed controls, relative offsets, color gradient data, and warp types.

2.  **Post-Processing: Normal Calculation & Shading**
    *   Create `src/shaders/normal_shader.frag`:  This shader takes the output of the noise shader as input.
    *   Calculate Normals: Use a central difference method to approximate the surface normal at each pixel based on neighboring noise values.
    *   Implement Diffuse Shading: Calculate the dot product of the normal vector and the light direction vector to determine the diffuse lighting intensity.
    *   Apply Lighting: Use the diffuse lighting intensity to modulate the final color of the pixel, and the lighting color.
    *   Pass lighting controls as uniforms from JavaScript (light direction and color).

3.  **Integration:**
    *   Use two PIXI.Sprites.
        * The first sprite will render out the Noise pass.
        * The second sprite will sample the output of the first with the `normal_shader.frag`
    *   Render the noise shader output to a `PIXI.RenderTexture`.
    *   Apply the normal shader to a second sprite, sampling the RenderTexture from the noise shader.
    *   Compose the sprites on the stage.

4.  **Experimentation & Optimization**
    *   Tweak parameters using the UI controls.
    *   Profile the shader's performance and optimize GLSL code. This is especially important with post-processing.
    *   Consider adding ambient and specular lighting.

**IV. Polishing & Deployment**

1.  **Code Cleanup & Refactoring**
    *   Lint code.
    *   Add comments.
    *   Refactor repetitive/poorly structured code.

2.  **Performance Testing**
    *   Test on different devices.
    *   Use browser developer tools for profiling.

3.  **Deployment (Optional)**
    *   Build using `npm run build`.
    *   Deploy the `dist` directory to Netlify, GitHub Pages, Vercel, or similar.

**Key Considerations & Best Practices:**

*   Modular Code
*   Error Handling
*   Performance Optimization
*   Documentation
*   Incremental Development
*   Version Control (Git)
*   UI/UX Design: Prioritize clarity, intuitiveness, and a slim, sleek aesthetic.
*   Post-Processing Performance: Be mindful of the performance impact of post-processing effects.

